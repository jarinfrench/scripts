/******************************************************************************
* This script reads a file as generated by extract_all_energies.sh, and
* calculates the per atom energy at the grain boundary.  The filename can be
* passed in via command line.  Note that this program expects a filename in the
* format of 111Tilt_total_energies.csv
* IMPORTANT PARAMETERS
*   grain radius: the radius of the grain that was specified when rotating the grain.
*     note that this assumes a cylindrical grain.  Given in Angstroms.
*   grain thickness: the thickness of the grain (determined by Lz).  This is given
*     in Angstroms.
******************************************************************************/
#include <iostream>
#include <iomanip>
#include <fstream>
#include <string>
#include <algorithm>
#include <cxxopts.hpp>
#include "error_code_defines.h"

using namespace std;

#define PI 3.14159265358979
#define eV2J 16.0218 // converts eV/angstrom^2 to J/m^2

template <typename T>
void checkFileStream(T& stream, const string& file)
{
  if (stream.fail())
  {
    cout << "Error opening file \"" << file << "\"\n";
    exit(FILE_OPEN_ERROR);
  }
}

double calculateArea(const bool is_sphere, const double& radius, const double& Lz)
{
  if (is_sphere) {return 4 * PI * radius * radius;} // spherical boundary
  else {return 2 * PI * radius * Lz;} // cylindrical boundary
}

void parseFile(const string& filename, const string& outfile, const double& gb_area)
{
  double theta, e_single, eGB, gbe; // angle, single crystal energy value, grain boundary energy value, grain boundary energy
  int N_0, N; // number of atoms for single grain, rotated grain

  ifstream fin(filename.c_str());
  checkFileStream(fin, filename);

  ofstream fout(outfile.c_str());
  checkFileStream(fout, outfile);

  // Assumes the first line from fin contains the original, single grain.
  fin >> theta >> e_single >> N_0;

  // The GBE here is assigned a value of 0
  fout << theta << "," << setprecision(15) << 0.0 << endl;

  // Read the rest of the file and calculate the GBE for each line:
  while (fin >> theta >> eGB >> N)
  {
    gbe = (eGB - (e_single / N_0) * N) / gb_area * eV2J; // calculate the GBE
    fout << theta << "," << setprecision(15) << gbe << endl;
  }

  fin.close();
  fout.close();
}

int main(int argc, char** argv)
{
  string filename, outfile;
  char boundary_type;
  bool is_sphere = false;
  double Lz, r_grain;

  try
  {
    cxxopts::Options options(argv[0], "Calculate the grain boundary energy based on LAMMPS results.");
    options
      .positional_help("file radius")
      .show_positional_help();

    options
      .allow_unrecognised_options()
      .add_options()
        ("f,file", "Input file containing a list of energies (energies are assumed to be in eV. Values are generated via extract_all_energies.sh)", cxxopts::value<string>(filename), "file")
        ("o,output", "Name of the output file.  Default replaces \"_total*\" with \"_individual_energy.csv\"", cxxopts::value<string>(outfile), "output")
        ("r,radius", "The radius of the grain, in Angstroms", cxxopts::value<double>(r_grain), "radius")
        ("b,boundary-type", "The type of boundary being examined.  Options are (c)ylinder or (s)phere.", cxxopts::value<char>(boundary_type)->default_value("c"), "c|s")
        ("t,Lz", "Grain thickness (required for cylindrical boundaries)", cxxopts::value<double>(Lz)->default_value("0.0"), "Lz")
        ("h,help", "Show the help");

    options.parse_positional({"file", "radius"});
    auto result = options.parse(argc, argv);

    if (result.count("help") || !(result.count("file") && result.count("radius")))
    {
      cout << options.help() << endl;
      return EXIT_SUCCESS;
    }

    if (boundary_type != 'c')
    {
      if (boundary_type != 's')
      {
        cout << "Error: Please specify either (c)ylinder or (s)phere for the boundary type.\n";
        return INPUT_FORMAT_ERROR;
      }
      else {is_sphere = true;}
    }
    else
    {
      if (!(result.count("Lz")))
      {
        cout << "Error: cylindrical grain boundary energy calculations requires the grain thickness parameter.\n";
        return INPUT_FORMAT_ERROR;
      }
    }

    if (result.count("file") && result.count("radius"))
    {
      double gb_area = calculateArea(is_sphere, r_grain, Lz);
      if (!(result.count("output")))
      {
        outfile = filename.substr(0,filename.find("_total")) + "_individual_energy.csv";
      }
      parseFile(filename, outfile, gb_area);
    }
  }
  catch (const cxxopts::OptionException& e)
  {
    cout << "Error parsing options: " << e.what() << endl;
    return OPTION_PARSING_ERROR;
  }

  return EXIT_SUCCESS;
}
